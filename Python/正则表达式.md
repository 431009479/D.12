## 正则表达式

正则表达式是一个特殊的字符序列，它能帮助你方便的检查一个字符串是否与某种模式匹配。

re 模块使 Python 语言拥有全部的正则表达式功能。

re 模块也提供了与这些方法功能完全一致的函数，这些函数使用一个模式字符串做为它们的第一个参数。

#### re.match函数

re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。

```python

```

#### re.search方法

re.search 扫描整个字符串并返回第一个成功的匹配。

```python

```

### findall

在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表。

**注意：** match 和 search 是匹配一次 findall 匹配所有。

```python

```



| 参数    | 描述                                                         |
| :------ | :----------------------------------------------------------- |
| pattern | 匹配的正则表达式                                             |
| string  | 要匹配的字符串。                                             |
| flags   | 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。参见：[正则表达式修饰符 - 可选标志](https://www.runoob.com/python/python-reg-expressions.html#flags) |

```python
pattern : 一个字符串形式的正则表达式
flags : 可选，表示匹配模式，比如忽略大小写，多行模式等，具体参数为：
re.I 忽略大小写
re.L 表示特殊字符集 \w, \W, \b, \B, \s, \S 依赖于当前环境
re.M 多行模式
re.S 即为 . 并且包括换行符在内的任意字符（. 不包括换行符）
re.U 表示特殊字符集 \w, \W, \b, \B, \d, \D, \s, \S 依赖于 Unicode 字符属性数据库
re.X 为了增加可读性，忽略空格和 # 后面的注释
```



```python
import re

str = "yangguo8890long110"
res = re.match("yangguo\d",str)   #match 必须从开头开始匹配
result = res.group()   #得到匹配结果
print(result)

    #1 '.'     默认匹配除\n之外的任意一个字符，若指定flag DOTALL,则匹配任意字符，包括换行
res1 = re.match("^.","yangguo8890long110")
print(res1)
print(res1.group())
res1 = re.match("yang.","yangguo8890long110")
print("1",res1)    #<_sre.SRE_Match object; span=(0, 5), match='yangg'>

    #2 '^'     匹配字符开头，以某个字符开头，可以指定flags MULTILINE,
res2 = re.match("^yangguo\d","yangguo8890long110")
print(res2) #<_sre.SRE_Match object; span=(0, 8), match='yangguo8'>

    # 3'$'     匹配的目标字符串 str 必须以$前面的字符结尾，或e.search("foo$","bfoo\nsdfsf",flags=re.MULTILINE).group()也可以
res3 = re.search("l.+0$","yangguo8890long120")
print("3",res3)   #3 <_sre.SRE_Match object; span=(11, 18), match='long120'>
res3 = re.search("l.+1$","yangguo8890long120")
print("3",res3)   #3 None

    # 4'*'     匹配*号前的字符0次或多次，re.findall("ab*","cabb3abcbbac")  结果为['abb', 'ab', 'a']  #表示*前面的b是可有可无的，但a必须存在
    # 5'+'     匹配前一个字符1次或多次，re.findall("ab+","ab+cd+abb+bba") 结果['ab', 'abb']          #表示+前面的必须以ab开头，b可有多个
res5 = re.search("l[a-z]+g","yangguo8890longnv1208")   #可以表示以某个字符结束
print(res5)  #<_sre.SRE_Match object; span=(11, 15), match='long'>
res5 = re.search("998.+998","yang 998guoxiao998 .s")  #匹配 998中间的字符，表示以 *开头，以* 结尾
print(res5) #<_sre.SRE_Match object; span=(5, 18), match='998guoxiao998'>
    # 6'?'     匹配?前面的一个字符1次或0次
res6 = re.search("889?","yannngguang889huan")
print(res6)#<_sre.SRE_Match object; span=(11, 14), match='889'>
res6 = re.search("889?","yannngguang88huan")#?前面的一个字符可以不匹配
print(res6)#<_sre.SRE_Match object; span=(11, 13), match='88'>
res6 = re.search("889?","yannngguang8huan")
print(res6)#None
    # 7'{m}'   匹配前一个字符m次
res7 = re.search("[0-9]{3}","ya4nn1n5gg6ua7ng892huan") #匹配连续的三个数字
print(res7)#<_sre.SRE_Match object; span=(16, 19), match='892'>
    # 8'{n,m}' 匹配前一个字符n到m次，re.findall("ab{1,3}","abb abc abbcbbb") 结果'abb', 'ab', 'abb']
res8 = re.search("[0-9]{2,3}","ya4nn1n5gg6ua17ng892huan") #匹配连续的两个数字或者连续的三个数字
print(res8)#<_sre.SRE_Match object; span=(13, 15), match='17'>
res8 = re.findall("[0-9]{1,3}","ya4nn1n5gg6ua17ng892huan") #匹配所有的数字，最多三位
print(res8)#['4', '1', '5', '6', '17', '892']
    # 9'|'     匹配|左或|右的字符，re.search("abc|ABC","ABCBabcCD").group() 结果'ABC'
res9 = re.search("123|abc","uyunjabckih123")
print(res9)
    # 10'(...)' 分组匹配，把括号里的字符看做一个整体，re.search("(abc){2}a(123|456)c", "abcabca456c").group() 结果 abcabca456c
res10 = re.search("(123){2}.+(i){2}","yuhiinyi123123iyhii321")#匹配123 两次
print(res10)

    # 11'\A'    只从字符开头匹配，re.search("\Aabc","alexabc") 是匹配不到的
    # 12'\Z'    匹配字符结尾，同$
    # 13'\d'    匹配数字0-9
    # 14'\D'    匹配非数字
res14 = re.search("\D+","234HKJU98+()")
print(res14) #<_sre.SRE_Match object; span=(3, 7), match='HKJU'>
res14 = re.findall("\D+","234HKJU98+()")
print(res14)#['HKJU', '+()']
    # 15'\w'    匹配[A-Za-z0-9]
    # 16'\W'    匹配非[A-Za-z0-9]
    # 17'\s'     匹配空白字符、\t、\n、\r , re.search("\s+","ab\tc1\n3").group() 结果 '\t'
    #18'[a-z]'  匹配所有小写字母一次
    #19'[A-Z]'  匹配所有大写字母一次
    #20'[a-zA-Z]'  匹配所有写字母一次,不分大小写
```

