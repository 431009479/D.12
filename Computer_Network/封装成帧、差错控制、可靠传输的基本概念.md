# 封装成帧、差错控制、可靠传输的基本概念

## 封装成帧

**封装成帧组装成帧就是在一段数据的前后部分添加首部和尾部，这样就构成了一个帧**。帧是数据链路层的数据传送单元。接收端再收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束。

首部和尾部包含很多控制信息，其中一个重要作用就是：**帧定界（确定帧的界限）**。帧定界可以使用特殊的**帧定界符**。控制字符**SOH（Start Of Header）**放在一帧的最前面，表示帧的首部开始。另一个控制符**EOT（End Of Transmission）**表示帧结束。

**帧同步**：接收方应当能够从接收到的二进制比特流中区分出帧的起始和终止。
**帧长**：帧的数据部分长度加上帧首部和帧尾部的长度。

**最大传送单元（MUT，Maximum Transfer Unit）**：每一种链路层都规定了所能传送帧的数据部分长度上限。

![img](https://upload-images.jianshu.io/upload_images/18464438-cc85b7e4069b24a8.png?imageMogr2/auto-orient/strip|imageView2/2/w/583/format/webp)

**透明传输**：指不管所传数据是什么样的比特组合，都应当能够在链路上传送。因此，链路层就看不见有什么妨碍数据传输的东西。

```c++
  当所传的数据中的比特组恰巧与某一个控制信息完全一样时，就必须采取适当的措施，使接收方不会将这样的错误认为是某种控制信息。这样才能保证数据链路层的传输是透明的。
例如如果传送的比特流中数据部分的数据恰好和帧尾部相同，那么在传输过程碰到该部分数据时，接收端可能误认为到这里传输结束了，那直接丢弃之后的数据了，这就会导致数据传输不完整，所以就要采取适当的措施，即使有这些问题也要保证数据能正确的传输，保证链路层对任何数据都能传送，在数据看来，链路层没有东西妨碍自己传送或者说链路层对数据是透明的。
```

###### 字符填充法

 当数据时由可打印的ASCII码组成的文本文件时，帧定界可以使用特殊的**帧定界符**。控制字符**SOH（Start Of Header）**放在一帧的最前面，表示帧的首部开始。另一个控制符**EOT（End Of Transmission）**表示帧结束。SOH和EOT是控制符的名称，它们的二进制编码分别是0000 0001和0000 0100。

```c++
 为了解决透明传输问题，在发送端的数据链路层中出现控制字符SOH或EOT的前面插入一个转义字符“ESC”（其二进制编码为0001 1011）。而在接收端的数据链路层在把数据送往网络层之前删除这个插入的转入字符。
    如果转义字符也在数据中，同样需要在转义字符前再插入一个转义字符。当接收端接收到连续的两个转义字符时，就删除其中前面的一格个。
```

![img](https://upload-images.jianshu.io/upload_images/18464438-029999d22851f162.png?imageMogr2/auto-orient/strip|imageView2/2/w/778/format/webp)

![img](https://upload-images.jianshu.io/upload_images/18464438-b7bf99e0faa0d9cf.png?imageMogr2/auto-orient/strip|imageView2/2/w/749/format/webp)

#### 零比特填充法

```c++
零比特填充法：在发送端，扫描整个信息字段，只要有连续的5个1，就立即填入1个0。在接收端收到一个帧时，先找到标志字段确定边界，再用硬件对比特流进行扫描。发现连续5个1时，就把后面的0删除。
零比特填充保证了透明传输，在传送的比特流中可以传送任意比特组合，而不会引起对帧边界的判断错误。
```

![img](https://upload-images.jianshu.io/upload_images/18464438-841e910da3af17ff.png?imageMogr2/auto-orient/strip|imageView2/2/w/557/format/webp)

## 差错控制

 差错的由来：现实中的通信链路都不会是理想的，由于噪声的存在，比特在传输的过程可能会产生差错。
 噪声分为全局性和局部性。

(1) 全局性噪声是由于线路电气特性所产生的**随机噪声（热噪声）**，是信道固有的，随机存在的。可以通过提高信噪比来减少或避免干扰。
 (2) 局部性噪声是外界特定的短暂原因所造成的**冲击噪声，是产生差错的主要原因**。可以利用编码技术来解决。

在数据传输过程中，差错可以分为**位错和帧错**。

 差错控制方法：**检错编码和纠错编码** 。

![img](https://upload-images.jianshu.io/upload_images/18464438-e97e85e0c0d61324.png?imageMogr2/auto-orient/strip|imageView2/2/w/769/format/webp)

#### 奇偶校验码

 奇偶检验码分为**奇检验码和偶检验码**。由n-1位信息元和在数据信息前的1位校验元组成。

1) 奇检验码：将数据转换为二进制数据，数据中的“1”的个数加上检验元的“1”的个数为奇数，如果接收端的1的个数是偶数，说明一定发生了错误。
 (2) 偶检验码：将数据转换为二进制数据，数据中的“1”的个数加上检验元的“1”的个数为偶数。如果接收端的1的个数是奇数，说明一定发生了错误。

 奇偶检验码的特点：
 (1) 奇偶检验码可以检测比特错，但是不能检测到是哪个比特出现差错。

 (2) 奇偶校验码只能检测出奇数个比特错误，检错能力为50%。

#### 循环冗余码CRC     https://www.jianshu.com/p/58dec9767b90

**冗余编码**：在数据发送前，先按某种关系附加上一定的冗余位，构成一个符合某一规则的码字后再发送。当要发送的有效数据变化时，相应的冗余位也随之变化，使码字遵从不变的规则。接收端根据收到的码字是否仍符合原规则，从而判断是否出错。

 **循环冗余检验原理**：在发送端，假设要发送k个比特，CRC运算就是在这k个比特后添加供查错检验的n位冗余码，n位冗余码又称为**帧检验序列FCS（Frame Check Sequence）**，然后构成一个帧发送出去，一共发送（k + n）个位。这n位冗余码可以通过发送的数据和一个数相除得来，这个数是收发双发事先约定好的数。接收端收到发送端发送的（k + n）位比特后，需要将这些比特位和FCS相除，如果余数是0，表示没有差错就接收，反之，则丢弃。

> FCS的生成以及接收端CRC检验都是由硬件实现的，处理很迅速，因此不会延误数据的传输。
>
> 注：链路层使用CRC检验，能够实现无比特差错的传输，只接受没有错误的信息，丢弃错误的数据，但这并**不是可靠传输**。**可靠传输是发送端发送什么，接收端就收到什么**。

## 可靠传输的基本概念

![img](https://img-blog.csdnimg.cn/20200504175446817.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NzI3Mzk1,size_16,color_FFFFFF,t_70)

![image.png](http://ww1.sinaimg.cn/large/00882iMugy1gel5qz3vovj30jo0a70x1.jpg)

###### 可靠传输的实现机制 — 停止-等待协议

###### 可靠传输的实现机制 — 回退N帧协议

######  可靠传输的实现机制 — 选择重传协议